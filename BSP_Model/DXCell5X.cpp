#pragma once
#include "StdAfx.h"
#include "ConstDef.h"
#include "SOrigSurf.h"
#include "DXMap.h"
#include "DXEdge.h"
#include "DXSharpEdge.h"
#include "DXBound.h"
//#include "RTriRandMesh.h"
#include "GQuadRender.h"
#include "DXCell5X.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

const int DXCell5X::EdgeFace[12][2] = // Faces given 0 - left, 1 - right if we look outside the cell in the appropriate coordinate direction
	{ { 1, 0}, { 2, 0}, { 0, 3}, { 0, 4}
	, { 5, 1}, { 5, 2}, { 3, 5}, { 4, 5}
	, { 4, 1}, { 1, 2}, { 3, 4}, { 2, 3}	};

const int DXCell5X::EdgeVert[12][2] = { { 0, 1 }, { 1, 3 }, { 2, 3 }, { 0, 2 },
										{ 4, 5 }, { 5, 7 }, { 6, 7 }, { 4, 6 },
										{ 0, 4 }, { 1, 5 }, { 2, 6 }, { 3, 7 } };

const int DXCell5X::contTable[256][32] = // The face number, MC edge number, ..., -2, -2, <Next contour>, -1 .....
{ { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 0, 3, 8, 4, 3, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 0, 0, 1, 2, 9, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 8, 4, 3, 0, 1, 2, 9, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 2, 1, 0, 2, 1, 10, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 0, 3, 8, 4, 3, -2, -2, 2, 1, 0, 2, 1, 10, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 2, 1, 10, 2, 9, 3, 0, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 8, 4, 3, 0, 2, 1, 10, 2, 9, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 3, 4, 11, 1, 2, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 11, 1, 2, 0, 0, 3, 8, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 1, 2, 9, 3, 0, -2, -2, 1, 2, 0, 3, 4, 11, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 11, 1, 2, 0, 1, 2, 9, 3, 8, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 10, 2, 1, 0, 3, 4, 11, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 10, 2, 1, 0, 0, 3, 8, 4, 11, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 2, 9, 3, 0, 0, 3, 4, 11, 1, 10, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 10, 2, 9, 3, 8, 4, 11, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 4, 5, 7, 4, 8, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 3, 0, 0, 3, 4, 5, 7, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 0, 0, 1, 2, 9, -2, -2, 4, 8, 3, 4, 5, 7, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 1, 2, 9, 3, 4, 5, 7, 4, 3, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 2, 1, 0, 2, 1, 10, -2, -2, 4, 8, 3, 4, 5, 7, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 4, 5, 7, 4, 3, 0, 0, -2, -2, 2, 1, 0, 2, 1, 10, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 2, 1, 10, 2, 9, 3, 0, -2, -2, 4, 8, 3, 4, 5, 7, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 7, 4, 3, 0, 2, 1, 10, 2, 9, 3, 4, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 8, 3, 4, 5, 7, -2, -2, 0, 3, 4, 11, 1, 2, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 4, 5, 7, 4, 11, 1, 2, 0, 0, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 2, 9, 3, 0, 0, 1, -2, -2, 4, 8, 3, 4, 5, 7, -2, -2, 1, 2, 0, 3, 4, 11, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 2, 9, 3, 4, 5, 7, 4, 11, 1, 2, 0, 1, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 10, 2, 1, 0, 3, 4, 11, -2, -2, 5, 7, 4, 8, 3, 4, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 11, 1, 10, 2, 1, 0, 0, 3, 4, 5, 7, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 4, 5, 7, 4, 8, -2, -2, 4, 11, 1, 10, 2, 9, 3, 0, 0, 3, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 2, 9, 3, 4, 5, 7, 4, 11, 1, 10, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 9, 2, 5, 5, 4, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 9, 2, 5, 5, 4, -2, -2, 0, 0, 3, 8, 4, 3, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 2, 5, 5, 4, 3, 0, 0, 1, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 2, 5, 5, 4, 3, 8, 4, 3, 0, 1, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 2, 1, 0, 2, 1, 10, -2, -2, 3, 9, 2, 5, 5, 4, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 3, 0, 0, 3, 8, -2, -2, 2, 1, 0, 2, 1, 10, -2, -2, 5, 4, 3, 9, 2, 5, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 2, 1, 10, 2, 5, 5, 4, 3, 0, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 3, 0, 2, 1, 10, 2, 5, 5, 4, 3, 8, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 9, 2, 5, 5, 4, -2, -2, 1, 2, 0, 3, 4, 11, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 11, 1, 2, 0, 0, 3, 8, -2, -2, 5, 4, 3, 9, 2, 5, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 2, 5, 5, 4, 3, 0, 0, 1, -2, -2, 1, 2, 0, 3, 4, 11, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 8, 4, 11, 1, 2, 0, 1, 2, 5, 5, 4, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 3, 4, 11, 1, 10, 2, 1, -2, -2, 3, 9, 2, 5, 5, 4, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 4, 3, 9, 2, 5, -2, -2, 1, 10, 2, 1, 0, 0, 3, 8, 4, 11, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 11, 1, 10, 2, 5, 5, 4, 3, 0, 0, 3, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 10, 2, 5, 5, 4, 3, 8, 4, 11, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 7, 4, 8, 3, 9, 2, 5, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 3, 0, 0, 3, 9, 2, 5, 5, 7, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 7, 4, 8, 3, 0, 0, 1, 2, 5, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 3, 0, 1, 2, 5, 5, 7, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 7, 4, 8, 3, 9, 2, 5, -2, -2, 1, 10, 2, 1, 0, 2, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 10, 2, 1, 0, 2, -2, -2, 4, 3, 0, 0, 3, 9, 2, 5, 5, 7, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 2, 5, 5, 7, 4, 8, 3, 0, 0, 2, 1, 10, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 3, 0, 2, 1, 10, 2, 5, 5, 7, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 9, 2, 5, 5, 7, 4, 8, -2, -2, 0, 3, 4, 11, 1, 2, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 2, 0, 0, 3, 9, 2, 5, 5, 7, 4, 11, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 2, 0, 3, 4, 11, -2, -2, 5, 7, 4, 8, 3, 0, 0, 1, 2, 5, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 7, 4, 11, 1, 2, 0, 1, 2, 5, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 8, 3, 9, 2, 5, 5, 7, -2, -2, 1, 10, 2, 1, 0, 3, 4, 11, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 0, 3, 9, 2, 5, 5, 7, 4, 11, 1, 10, 2, 1, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 0, 0, 3, 4, 11, 1, 10, 2, 5, 5, 7, 4, 8, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 11, 1, 10, 2, 5, 5, 7, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 2, 10, 1, 6, 5, 5, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 0, 3, 8, 4, 3, -2, -2, 5, 5, 2, 10, 1, 6, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 2, 9, 3, 0, 0, 1, -2, -2, 5, 5, 2, 10, 1, 6, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 8, 4, 3, 0, 1, 2, 9, -2, -2, 5, 5, 2, 10, 1, 6, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 6, 5, 5, 2, 1, 0, 2, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 6, 5, 5, 2, 1, 0, 2, -2, -2, 4, 3, 0, 0, 3, 8, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 6, 5, 5, 2, 9, 3, 0, 0, 2, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 2, 1, 6, 5, 5, 2, 9, 3, 8, 4, 3, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 2, 0, 3, 4, 11, -2, -2, 2, 10, 1, 6, 5, 5, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 0, 3, 8, 4, 11, 1, 2, -2, -2, 2, 10, 1, 6, 5, 5, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 0, 0, 1, 2, 9, -2, -2, 1, 2, 0, 3, 4, 11, -2, -2, 5, 5, 2, 10, 1, 6, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 5, 2, 10, 1, 6, -2, -2, 4, 11, 1, 2, 0, 1, 2, 9, 3, 8, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 3, 4, 11, 1, 6, 5, 5, 2, 1, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 5, 2, 1, 0, 0, 3, 8, 4, 11, 1, 6, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 0, 0, 3, 4, 11, 1, 6, 5, 5, 2, 9, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 11, 1, 6, 5, 5, 2, 9, 3, 8, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 5, 2, 10, 1, 6, -2, -2, 3, 4, 5, 7, 4, 8, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 3, 0, 0, 3, 4, 5, 7, -2, -2, 1, 6, 5, 5, 2, 10, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 1, 2, 9, 3, 0, -2, -2, 5, 5, 2, 10, 1, 6, -2, -2, 4, 8, 3, 4, 5, 7, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 2, 10, 1, 6, 5, 5, -2, -2, 5, 7, 4, 3, 0, 1, 2, 9, 3, 4, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 2, 1, 0, 2, 1, 6, 5, 5, -2, -2, 3, 4, 5, 7, 4, 8, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 5, 2, 1, 0, 2, 1, 6, -2, -2, 4, 3, 0, 0, 3, 4, 5, 7, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 8, 3, 4, 5, 7, -2, -2, 1, 6, 5, 5, 2, 9, 3, 0, 0, 2, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 2, 9, 3, 4, 5, 7, 4, 3, 0, 2, 1, 6, 5, 5, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 3, 4, 11, 1, 2, -2, -2, 5, 7, 4, 8, 3, 4, -2, -2, 2, 10, 1, 6, 5, 5, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 5, 2, 10, 1, 6, -2, -2, 1, 2, 0, 0, 3, 4, 5, 7, 4, 11, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 0, 0, 1, 2, 9, -2, -2, 3, 4, 5, 7, 4, 8, -2, -2, 1, 2, 0, 3, 4, 11, -2, -2, 5, 5, 2, 10, 1, 6, -2, -2 },
{ 4, 11, 1, 2, 0, 1, 2, 9, 3, 4, 5, 7, -2, -2, 5, 5, 2, 10, 1, 6, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 8, 3, 4, 5, 7, -2, -2, 5, 5, 2, 1, 0, 3, 4, 11, 1, 6, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 11, 1, 6, 5, 5, 2, 1, 0, 0, 3, 4, 5, 7, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 6, 5, 5, 2, 9, 3, 0, 0, 3, 4, 11, -2, -2, 4, 8, 3, 4, 5, 7, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 7, 4, 11, 1, 6, 5, 5, 2, 9, 3, 4, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 4, 3, 9, 2, 10, 1, 6, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 2, 10, 1, 6, 5, 4, 3, 9, -2, -2, 0, 0, 3, 8, 4, 3, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 0, 0, 1, 2, 10, 1, 6, 5, 4, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 6, 5, 4, 3, 8, 4, 3, 0, 1, 2, 10, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 4, 3, 9, 2, 1, 0, 2, 1, 6, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 3, 0, 0, 3, 8, -2, -2, 5, 4, 3, 9, 2, 1, 0, 2, 1, 6, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 4, 3, 0, 0, 2, 1, 6, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 4, 3, 8, 4, 3, 0, 2, 1, 6, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 4, 3, 9, 2, 10, 1, 6, -2, -2, 4, 11, 1, 2, 0, 3, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 2, 0, 0, 3, 8, 4, 11, -2, -2, 5, 4, 3, 9, 2, 10, 1, 6, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 3, 4, 11, 1, 2, -2, -2, 1, 6, 5, 4, 3, 0, 0, 1, 2, 10, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 1, 2, 10, 1, 6, 5, 4, 3, 8, 4, 11, 1, 2, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 6, 5, 4, 3, 9, 2, 1, 0, 3, 4, 11, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 2, 1, 0, 0, 3, 8, 4, 11, 1, 6, 5, 4, 3, 9, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 0, 0, 3, 4, 11, 1, 6, 5, 4, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 6, 5, 4, 3, 8, 4, 11, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 2, 10, 1, 6, 5, 7, 4, 8, 3, 9, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 7, 4, 3, 0, 0, 3, 9, 2, 10, 1, 6, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 1, 2, 10, 1, 6, 5, 7, 4, 8, 3, 0, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 1, 2, 10, 1, 6, 5, 7, 4, 3, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 8, 3, 9, 2, 1, 0, 2, 1, 6, 5, 7, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 9, 2, 1, 0, 2, 1, 6, 5, 7, 4, 3, 0, 0, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 6, 5, 7, 4, 8, 3, 0, 0, 2, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 7, 4, 3, 0, 2, 1, 6, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 2, 0, 3, 4, 11, -2, -2, 4, 8, 3, 9, 2, 10, 1, 6, 5, 7, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 7, 4, 11, 1, 2, 0, 0, 3, 9, 2, 10, 1, 6, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 7, 4, 8, 3, 0, 0, 1, 2, 10, 1, 6, -2, -2, 1, 2, 0, 3, 4, 11, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 6, 5, 7, 4, 11, 1, 2, 0, 1, 2, 10, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 6, 5, 7, 4, 8, 3, 9, 2, 1, 0, 3, 4, 11, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 0, 3, 9, 2, 1, -2, -2, 4, 11, 1, 6, 5, 7, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 11, 1, 6, 5, 7, 4, 8, 3, 0, 0, 3, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 7, 4, 11, 1, 6, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 7, 5, 6, 1, 11, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 3, 0, 0, 3, 8, -2, -2, 1, 11, 4, 7, 5, 6, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 0, 0, 1, 2, 9, -2, -2, 1, 11, 4, 7, 5, 6, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 1, 2, 9, 3, 8, 4, 3, -2, -2, 1, 11, 4, 7, 5, 6, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 10, 2, 1, 0, 2, -2, -2, 5, 6, 1, 11, 4, 7, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 2, 1, 0, 2, 1, 10, -2, -2, 4, 3, 0, 0, 3, 8, -2, -2, 5, 6, 1, 11, 4, 7, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 2, 9, 3, 0, 0, 2, 1, 10, -2, -2, 5, 6, 1, 11, 4, 7, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 6, 1, 11, 4, 7, -2, -2, 3, 8, 4, 3, 0, 2, 1, 10, 2, 9, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 2, 0, 3, 4, 7, 5, 6, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 0, 3, 8, 4, 7, 5, 6, 1, 2, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 7, 5, 6, 1, 2, 0, 3, -2, -2, 3, 0, 0, 1, 2, 9, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 6, 1, 2, 0, 1, 2, 9, 3, 8, 4, 7, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 7, 5, 6, 1, 10, 2, 1, 0, 3, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 8, 4, 7, 5, 6, 1, 10, 2, 1, 0, 0, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 10, 2, 9, 3, 0, 0, 3, 4, 7, 5, 6, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 8, 4, 7, 5, 6, 1, 10, 2, 9, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 8, 3, 4, 5, 6, 1, 11, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 6, 1, 11, 4, 3, 0, 0, 3, 4, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 6, 1, 11, 4, 8, 3, 4, -2, -2, 2, 9, 3, 0, 0, 1, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 3, 0, 1, 2, 9, 3, 4, 5, 6, 1, 11, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 8, 3, 4, 5, 6, 1, 11, -2, -2, 0, 2, 1, 10, 2, 1, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 2, 1, 0, 2, 1, 10, -2, -2, 5, 6, 1, 11, 4, 3, 0, 0, 3, 4, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 11, 4, 8, 3, 4, 5, 6, -2, -2, 2, 9, 3, 0, 0, 2, 1, 10, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 3, 0, 2, 1, 10, 2, 9, 3, 4, 5, 6, 1, 11, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 2, 0, 3, 4, 8, 3, 4, 5, 6, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 2, 0, 0, 3, 4, 5, 6, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 1, 2, 9, 3, 0, -2, -2, 3, 4, 5, 6, 1, 2, 0, 3, 4, 8, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 2, 0, 1, 2, 9, 3, 4, 5, 6, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 2, 1, 0, 3, 4, 8, 3, 4, 5, 6, 1, 10, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 6, 1, 10, 2, 1, 0, 0, 3, 4, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 3, 4, 8, 3, 4, 5, 6, 1, 10, 2, 9, 3, 0, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 10, 2, 9, 3, 4, 5, 6, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 4, 3, 9, 2, 5, -2, -2, 4, 7, 5, 6, 1, 11, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 0, 3, 8, 4, 3, -2, -2, 5, 4, 3, 9, 2, 5, -2, -2, 1, 11, 4, 7, 5, 6, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 0, 0, 1, 2, 5, 5, 4, -2, -2, 4, 7, 5, 6, 1, 11, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 11, 4, 7, 5, 6, -2, -2, 2, 5, 5, 4, 3, 8, 4, 3, 0, 1, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 9, 2, 5, 5, 4, -2, -2, 1, 10, 2, 1, 0, 2, -2, -2, 4, 7, 5, 6, 1, 11, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 6, 1, 11, 4, 7, -2, -2, 2, 1, 0, 2, 1, 10, -2, -2, 0, 0, 3, 8, 4, 3, -2, -2, 5, 4, 3, 9, 2, 5, -2, -2 },
{ 4, 7, 5, 6, 1, 11, -2, -2, 0, 2, 1, 10, 2, 5, 5, 4, 3, 0, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 2, 5, 5, 4, 3, 8, 4, 3, 0, 2, 1, 10, -2, -2, 1, 11, 4, 7, 5, 6, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 2, 0, 3, 4, 7, 5, 6, -2, -2, 2, 5, 5, 4, 3, 9, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 9, 2, 5, 5, 4, -2, -2, 5, 6, 1, 2, 0, 0, 3, 8, 4, 7, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 6, 1, 2, 0, 3, 4, 7, -2, -2, 3, 0, 0, 1, 2, 5, 5, 4, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 8, 4, 7, 5, 6, 1, 2, 0, 1, 2, 5, 5, 4, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 9, 2, 5, 5, 4, -2, -2, 4, 7, 5, 6, 1, 10, 2, 1, 0, 3, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 7, 5, 6, 1, 10, 2, 1, 0, 0, 3, 8, -2, -2, 3, 9, 2, 5, 5, 4, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 10, 2, 5, 5, 4, 3, 0, 0, 3, 4, 7, 5, 6, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 4, 3, 8, 4, 7, 5, 6, 1, 10, 2, 5, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 9, 2, 5, 5, 6, 1, 11, 4, 8, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 2, 5, 5, 6, 1, 11, 4, 3, 0, 0, 3, 9, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 11, 4, 8, 3, 0, 0, 1, 2, 5, 5, 6, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 2, 5, 5, 6, 1, 11, 4, 3, 0, 1, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 2, 1, 0, 2, 1, 10, -2, -2, 1, 11, 4, 8, 3, 9, 2, 5, 5, 6, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 6, 1, 11, 4, 3, 0, 0, 3, 9, 2, 5, -2, -2, 2, 1, 0, 2, 1, 10, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 2, 5, 5, 6, 1, 11, 4, 8, 3, 0, 0, 2, 1, 10, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 10, 2, 5, 5, 6, 1, 11, 4, 3, 0, 2, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 8, 3, 9, 2, 5, 5, 6, 1, 2, 0, 3, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 0, 3, 9, 2, 5, 5, 6, 1, 2, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 8, 3, 0, 0, 1, 2, 5, 5, 6, 1, 2, 0, 3, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 1, 2, 5, 5, 6, 1, 2, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 6, 1, 10, 2, 1, 0, 3, 4, 8, 3, 9, 2, 5, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 2, 5, 5, 6, 1, 10, 2, 1, 0, 0, 3, 9, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 0, 0, 3, 4, 8, -2, -2, 2, 5, 5, 6, 1, 10, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 10, 2, 5, 5, 6, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 5, 2, 10, 1, 11, 4, 7, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 5, 2, 10, 1, 11, 4, 7, -2, -2, 3, 8, 4, 3, 0, 0, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 11, 4, 7, 5, 5, 2, 10, -2, -2, 0, 1, 2, 9, 3, 0, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 7, 5, 5, 2, 10, 1, 11, -2, -2, 0, 1, 2, 9, 3, 8, 4, 3, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 2, 1, 0, 2, 1, 11, 4, 7, 5, 5, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 0, 3, 8, 4, 3, -2, -2, 4, 7, 5, 5, 2, 1, 0, 2, 1, 11, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 7, 5, 5, 2, 9, 3, 0, 0, 2, 1, 11, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 2, 1, 11, 4, 7, 5, 5, 2, 9, 3, 8, 4, 3, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 5, 2, 10, 1, 2, 0, 3, 4, 7, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 2, 0, 0, 3, 8, 4, 7, 5, 5, 2, 10, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 2, 9, 3, 0, 0, 1, -2, -2, 0, 3, 4, 7, 5, 5, 2, 10, 1, 2, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 2, 0, 1, 2, 9, 3, 8, 4, 7, 5, 5, 2, 10, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 5, 2, 1, 0, 3, 4, 7, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 2, 1, 0, 0, 3, 8, 4, 7, 5, 5, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 5, 2, 9, 3, 0, 0, 3, 4, 7, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 2, 9, 3, 8, 4, 7, 5, 5, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 8, 3, 4, 5, 5, 2, 10, 1, 11, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 0, 3, 4, 5, 5, 2, 10, 1, 11, 4, 3, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 0, 0, 1, 2, 9, -2, -2, 2, 10, 1, 11, 4, 8, 3, 4, 5, 5, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 4, 5, 5, 2, 10, 1, 11, 4, 3, 0, 1, 2, 9, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 5, 2, 1, 0, 2, 1, 11, 4, 8, 3, 4, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 11, 4, 3, 0, 0, 3, 4, 5, 5, 2, 1, 0, 2, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 5, 2, 9, 3, 0, 0, 2, 1, 11, 4, 8, 3, 4, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 2, 9, 3, 4, 5, 5, -2, -2, 0, 2, 1, 11, 4, 3, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 4, 5, 5, 2, 10, 1, 2, 0, 3, 4, 8, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 4, 5, 5, 2, 10, 1, 2, 0, 0, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 5, 2, 10, 1, 2, 0, 3, 4, 8, 3, 4, -2, -2, 3, 0, 0, 1, 2, 9, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 2, 9, 3, 4, 5, 5, 2, 10, 1, 2, 0, 1, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 3, 4, 8, 3, 4, 5, 5, 2, 1, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 0, 3, 4, 5, 5, 2, 1, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 0, 0, 3, 4, 8, 3, 4, 5, 5, 2, 9, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 2, 9, 3, 4, 5, 5, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 11, 4, 7, 5, 4, 3, 9, 2, 10, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 0, 3, 8, 4, 3, -2, -2, 1, 11, 4, 7, 5, 4, 3, 9, 2, 10, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 4, 3, 0, 0, 1, 2, 10, 1, 11, 4, 7, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 4, 3, 8, 4, 3, 0, 1, 2, 10, 1, 11, 4, 7, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 2, 1, 11, 4, 7, 5, 4, 3, 9, 2, 1, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 11, 4, 7, 5, 4, 3, 9, 2, 1, 0, 2, -2, -2, 0, 0, 3, 8, 4, 3, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 2, 1, 11, 4, 7, 5, 4, 3, 0, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 3, 0, 2, 1, 11, 4, 7, 5, 4, 3, 8, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 9, 2, 10, 1, 2, 0, 3, 4, 7, 5, 4, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 7, 5, 4, 3, 9, 2, 10, 1, 2, 0, 0, 3, 8, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 2, 10, 1, 2, 0, 3, 4, 7, 5, 4, 3, 0, 0, 1, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 1, 2, 10, 1, 2, -2, -2, 3, 8, 4, 7, 5, 4, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 7, 5, 4, 3, 9, 2, 1, 0, 3, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 8, 4, 7, 5, 4, 3, 9, 2, 1, 0, 0, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 4, 3, 0, 0, 3, 4, 7, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 5, 4, 3, 8, 4, 7, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 8, 3, 9, 2, 10, 1, 11, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 1, 11, 4, 3, 0, 0, 3, 9, 2, 10, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 8, 3, 0, 0, 1, 2, 10, 1, 11, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 3, 0, 1, 2, 10, 1, 11, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 9, 2, 1, 0, 2, 1, 11, 4, 8, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 2, 1, 11, 4, 3, 0, 0, 3, 9, 2, 1, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 0, 0, 2, 1, 11, 4, 8, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 4, 3, 0, 2, 1, 11, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 2, 10, 1, 2, 0, 3, 4, 8, 3, 9, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 9, 2, 10, 1, 2, 0, 0, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 1, 2, 10, 1, 2, 0, 3, 4, 8, 3, 0, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 1, 2, 10, 1, 2, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 2, 1, 0, 3, 4, 8, 3, 9, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 0, 0, 3, 9, 2, 1, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ 3, 0, 0, 3, 4, 8, -2, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
{ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 } };

int DXCell5X::MakeFinalCycle(const FEP FaceEdgeP)
{
	// It is assumed that every face contains 2 or 0 (but not 4) edges with points
	// Additional point can be the last point in the FinalCycle but can't be the first point
	bool EdgeFree[12] = {true, true, true, true, true, true, true, true, true, true, true, true};
	// Count whole points number
	int PointOnEdgeCount = 0;
	for(int i = 0; i < 6; ++i)
		PointOnEdgeCount += FaceEdgeP[i][PC];

	int Ci = 0;
	for (; Ci < DXBigCell5X::MAX_FinalCycles; ++Ci)
	{
		pBigCell->GetGData()->FinalCycle = pBigCell->GetGData()->FinalCycles[Ci];
		// Find first edge with a point
		int CurEdge = 0;
		const DXEdge *pFirst = NULL;
		for (; CurEdge < 12; ++CurEdge)
		{
			if (!EdgeFree[CurEdge])
				continue;
			if ((pFirst = GetEdge(CurEdge)) != NULL)
				break;
		}
		if (CurEdge >= 12)
			return Ci;
		// Find first face
		int FirstFace = (pFirst->GetRout()) ?// the beginning of the edge is occupied
				EdgeFace[CurEdge][1] : // right 
				EdgeFace[CurEdge][0]; // left
		// Make cycle
		int CurFace = FirstFace;
		do
		{
			pBigCell->GetGData()->FinalCycle.PutBack(CurEdge, false);
			int NextEdge = FaceEdgeP[CurFace][(FaceEdgeP[CurFace][EN] == CurEdge) ? EN + 1 : EN];
			if (GetBound(CurFace) != NULL)// if CurFace contains an additional point
				pBigCell->GetGData()->FinalCycle.PutBack(CurFace, true);
			CurFace = EdgeFace[NextEdge][(EdgeFace[NextEdge][0] == CurFace) ? 1 : 0];
			CurEdge = NextEdge;
		}
		while(CurFace != FirstFace);

		PointOnEdgeCount -= 2 * pBigCell->GetGData()->FinalCycle.GetSize();
		if(PointOnEdgeCount > 5)
		{// Mark used edges
			for(int k = 0; k < pBigCell->GetGData()->FinalCycle.GetSize(); ++k)
				EdgeFree[pBigCell->GetGData()->FinalCycle.GetValAt(k)] = false;
		}
		else
			break;
	}
	return Ci; // The number of non empty final cycles
}

DXCell5X & DXCell5X::Clear()
{
	for (int i = 0; i< 12; ++i) // обнул€ем все ребра €чейки
		*(Edges + i) = UINT_MAX;
	for (int i = 0; i< 6; ++i) // обнул€ем все грани €чейки
		*(Bounds + i) = UINT_MAX;
	return *this;
}

const DXBound *DXCell5X::GetBound(int Num) const
{
	std::vector <DXBound> &MapBounds = pBigCell->GetMapBounds();
	return Bounds[Num] == UINT_MAX ? nullptr : &MapBounds[Bounds[Num]];
}

const DXEdge *DXCell5X::GetEdge(int Num) const
{ 
	std::vector <DXEdge> &MapEdges = pBigCell->GetMapEdges();
	return Edges[Num] == UINT_MAX ? nullptr : &MapEdges[Edges[Num]];
}

int DXCell5X::GetBufNum(const DXFinalCycle::Elem &El) const
{
	if(El.BoundOrEdge)
		return GetBound(El.Number)->GetPoint()[0];
	else
		return GetEdge(El.Number)->GetPoint();
}
int DXCell5X::GetBufNum(const DXFinalCycle::Elem &El, bool FirstNormal) const
{
	if(El.BoundOrEdge)
		return GetBound(El.Number)->GetPoint()[FirstNormal ? 0 : 1];
	else
		return GetEdge(El.Number)->GetPoint();
}
bool DXCell5X::IntersectionPoint(double *outi, double *outj, float *BUFBase0, float *BUFBase1, const int BufShifts[5])
{
	const float A0 = *(BUFBase0 + BufShifts[3]);
	const float B0 = *(BUFBase0 + BufShifts[4]);
	const float A1 = *(BUFBase1 + BufShifts[3]);
	const float B1 = *(BUFBase1 + BufShifts[4]);
	double D = A0 * B1 - A1 * B0; // синус угла между нормал€ми
	if (D * D < MINAR * ((A0 * A0 + B0 * B0) * (A1 * A1 + B1 * B1))) // test 2D projections of normals for calculation (division) correctness only
		return false;												// 3D test is in FindBoundPoint with user defined tolerance

	D = 1. / (-D);
	const float i0 = *(BUFBase0 + BufShifts[0]);
	const float j0 = *(BUFBase0 + BufShifts[1]);
	const float i1 = *(BUFBase1 + BufShifts[0]);
	const float j1 = *(BUFBase1 + BufShifts[1]);
	const double R0 = (-A0) * i0 + (-B0) * j0; 
	const double R1 = (-A1) * i1 + (-B1) * j1; 
	*outi = (R0 * B1 - R1 * B0) * D;
	*outj = (A0 * R1 - A1 * R0) * D;

	return true;
}

void DXCell5X::MakeAdditPoints(const DXCellInd &Key, const FEP FaceEdgeP)
{
	static const int LocalGlobalFace[3] = { 2, 3, 5};
	for(int LocalFaceNum = 0; LocalFaceNum < 3; ++LocalFaceNum)
	{
		int GlobalFaceNum = LocalGlobalFace[LocalFaceNum];
		const int *EdgeP = FaceEdgeP[GlobalFaceNum];
		if(EdgeP[PC] != 2) // Don't search for additional points for a face with 4 points or empty face
			continue;
		if(EdgeP[ID] == EdgeP[ID + 1]) // Same IDs
			continue;
		// Find point
		BPoint BoundP; // Don't initialize
		if(!FindBoundPoint(LocalFaceNum, EdgeP, BoundP))
			continue;
		EnsureInCell(Key, BoundP);
		StoreAdditPoint(BoundP, GlobalFaceNum, EdgeP);
	}
}

void DXCell5X::StoreAdditPoint(const BPoint &BoundP, int FaceNum, const int *EdgeP)
{
	std::vector <DXBound> &MapBounds = pBigCell->GetMapBounds();
	// Store point
	int curposbuf = pBigCell->GetTriangleArea().GetActSizeP();
	unsigned int NewBound = unsigned int(MapBounds.size());
	MapBounds.emplace_back();
	MapBounds[NewBound].SetPointInd(curposbuf);

	Bounds[FaceNum] = NewBound;// добавл€ем грань в €чейку
	// Make 2 points for the point found
	// Find normals
	// Normals in the founded point. N0 for the edge with the smaller number
	StoreNPC(pBigCell->GetTriangleArea().GetNextNP(), BoundP, EdgeP[ID]);

	// Normals in the founded point. N0 for the edge with the smaller number
	StoreNPC(pBigCell->GetTriangleArea().GetNextNP(), BoundP, EdgeP[ID + 1]);
}

int DXCell5X::RecoverWhenOnSurface(const DXCellInd &Key, const DXMap &Map)
{
	// Find "ON" vertexes and suspicious edges
	// Mark vertexes according to trusted edges only
	const int NeighbourVert[8][3] = { { 1, 2, 4 }, { 0, 3, 5 }, { 0, 3, 6 }, { 1, 2, 7 },
	{ 0, 5, 6 }, { 1, 4, 7 }, { 2, 4, 7 }, { 3, 5, 6 } };
	const int NeighbourEdge[8][3] = { { 0, 3, 8 }, { 0, 1, 9 }, { 3, 2, 10 }, { 1, 2, 11 },
	{ 8, 4, 7 }, { 9, 4, 5 }, { 10, 7, 6 }, { 11, 5, 6 } }; // Should correspond to NeighbourVert
	const int Edge2Dir[12] = { 0, 1, 0, 1, 0, 1, 0, 1, 2, 2, 2, 2 };

	double kX = Key.Ix * pBigCell->GetGData()->StepX + pBigCell->GetGData()->MinPointShift.GetX();
	double kY = Key.Iy * pBigCell->GetGData()->StepY + pBigCell->GetGData()->MinPointShift.GetY();
	double kZ = Key.Iz * pBigCell->GetGData()->StepZ + pBigCell->GetGData()->MinPointShift.GetZ();
	double dX = pBigCell->GetGData()->StepX;
	double dY = pBigCell->GetGData()->StepY;
	double dZ = pBigCell->GetGData()->StepZ;
	int SuspEdge[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };// -1 - start point is ON, 1 - end point is ON
	int vertFlags[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
	double Limits[12][2] = { { kX, kX + dX }, { kY, kY + dY }, { kX, kX + dX }, { kY, kY + dY },
							{ kX, kX + dX }, { kY, kY + dY }, { kX, kX + dX }, { kY, kY + dY },
							{ kZ, kZ + dZ }, { kZ, kZ + dZ }, { kZ, kZ + dZ }, { kZ, kZ + dZ } };
	//OutputDebugString("\n");
	//for (int i = 0; i < 12; ++i)
	//{
	//	CString S;
	//	S.Format("%d ", EdgeCell[i]);
	//	OutputDebugString(S);
	//}
	int NonSuspEdgesCount = 0;
	for (int i = 0; i < 12; ++i)
	{
		const DXEdge *pEdge = GetEdge(i);
		if (!pEdge)
			continue;
		auto Deg = pEdge->GetDegraded();
		if (Deg != 0)
		{
			SuspEdge[i] = pEdge->GetDegraded() * 2 - 3;// 1,2 -> -1, 1
			vertFlags[EdgeVert[i][Deg - 1]] = 2;
		}
		else
		{
			++NonSuspEdgesCount;
			int side = pEdge->GetRout() ? -1 : 1;
			int &b = vertFlags[EdgeVert[i][0]];
			int &e = vertFlags[EdgeVert[i][1]];
			if (b != 2)
			{
				if (b != 0)
				{
					if (b != side)
					{
						//OutputDebugString("\n internal error ");
						return -1;//internal error
					}
				}
				else
				{
					b = side;
				}
			}
			if (e != 2)
			{
				if (e != 0)
				{
					if (e != -side)
					{
						//OutputDebugString("\n internal error ");
						return -1;//internal error
					}
				}
				else
				{
					e = -side;
				}
			}
		}
	}
	//OutputDebugString("\n");
	//for (int i = 0; i < 8; ++i)
	//{
	//		CString S;
	//		S.Format("%d ", vertFlags[i]);
	//		OutputDebugString(S);
	//}
	for (int k = 0; k < 2; ++k) // max path length is 2
	{
		//OutputDebugString("\n");
		for (int i = 0; i < 12; ++i)
		{
			const DXEdge *pEdge = GetEdge(i);
			if (!pEdge)
			{
				if (abs(vertFlags[EdgeVert[i][0]]) == 1)
				{
					if (vertFlags[EdgeVert[i][1]] == 0)
					{
						vertFlags[EdgeVert[i][1]] = vertFlags[EdgeVert[i][0]];
					}
				}
				else if (abs(vertFlags[EdgeVert[i][1]]) == 1)
				{
					if (vertFlags[EdgeVert[i][0]] == 0)
					{
						vertFlags[EdgeVert[i][0]] = vertFlags[EdgeVert[i][1]];
					}
				}
			}
			//CString S;
			//S.Format("%d ", vertFlags[i]);
			//OutputDebugString(S);
		}
	}
	int MarkedNum = 0;
	int ONVertNum = 0;
	for (int i = 0; i < 8; ++i)
	{
		switch (vertFlags[i])
		{
		case 1:
		case -1:
			++MarkedNum;
			break;
		case 2:
			++ONVertNum;
			break;
		}
	}
	// Mark non marked edges if any
	if (MarkedNum + ONVertNum != 8)
	{
		for (int i = 0; i < 12; ++i)
		{
			const DXEdge *pEdge = GetEdge(i);
			if (!pEdge)
				continue;
			int NonDegradedSide = -(pEdge->GetDegraded() - 2);// 1,2 -> 1,0
			if (NonDegradedSide == 2)
				continue;
			if (vertFlags[EdgeVert[i][NonDegradedSide]] != 0)
				continue;
			int side = pEdge->GetRout() ? -1 : 1;
			vertFlags[EdgeVert[i][NonDegradedSide]] = (1 - NonDegradedSide * 2) * side;// (NonDegradedSide == 0 ? side : -side);
		}
		for (int k = 0; k < 2 ; ++k) // max path length is 2
		{
			for (int i = 0; i < 12; ++i)
			{
				const DXEdge *pEdge = GetEdge(i);
				if (!pEdge)
				{
					if (abs(vertFlags[EdgeVert[i][0]]) == 1)
					{
						if (vertFlags[EdgeVert[i][1]] == 0)
						{
							vertFlags[EdgeVert[i][1]] = vertFlags[EdgeVert[i][0]];
						}
					}
					else if (abs(vertFlags[EdgeVert[i][1]]) == 1)
					{
						if (vertFlags[EdgeVert[i][0]] == 0)
						{
							vertFlags[EdgeVert[i][0]] = vertFlags[EdgeVert[i][1]];
						}
					}
				}
				//CString S;
				//S.Format("%d ", vertFlags[i]);
				//OutputDebugString(S);
			}
		}
	}
	// Mark ON vertexes if any
	if (ONVertNum > 0)
	{
		for (int i = 0; i < 12; ++i) // Use non susp edges
		{
			const DXEdge *pEdge = GetEdge(i);
			if (!pEdge)
				continue;
			auto Deg = pEdge->GetDegraded();
			if (Deg != 0)
				continue;
			int side = pEdge->GetRout() ? -1 : 1;
			vertFlags[EdgeVert[i][0]] = side;
			vertFlags[EdgeVert[i][1]] = -side;
		}
		for (int i = 0; i < 8; ++i)
		{
			if (vertFlags[i] == 2)
				vertFlags[i] = 0;
		}
		if (NonSuspEdgesCount == 0)
		{
			if (ONVertNum == 4)
			{

				for (int i = 0; i < 12; ++i) 
				{
					const DXEdge *pEdge = GetEdge(i);
					if (!pEdge)
						continue;
					auto Deg = pEdge->GetDegraded();
					if (Deg != 2)
						break;
					int side = pEdge->GetRout() ? -1 : 1;
					vertFlags[EdgeVert[i][1]] = -side;
				}
			}
		}
		for (int kb = 0; kb < 2; ++kb) // Mark 2 neighbour vertexes
		{
			int vertFlagsBuf[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
			for (int i = 0; i < 8; ++i) 
			{
				if (vertFlags[i] != 0)
					continue;
				int MarkedNeighNum = 0;
				for (int ii = 0; ii < 3; ++ii)
					MarkedNeighNum += (vertFlags[NeighbourVert[i][ii]] == 0 ? 0 : 1);
				if (MarkedNeighNum != 2)
					continue;
				int Flag = vertFlags[NeighbourVert[i][0]] + vertFlags[NeighbourVert[i][1]] + vertFlags[NeighbourVert[i][2]];
				if (Flag == 0)
				{
					for (int iE = 0; iE < 3; ++iE)
					{
						const DXEdge *pNeighEdge = GetEdge(NeighbourEdge[i][iE]);
						if (pNeighEdge == nullptr)
							Flag += vertFlags[NeighbourVert[i][iE]]; // Because NeighbourVert corresponds to NeighbourEdge
					}
				}
				vertFlagsBuf[i] = Flag > 0 ? 1 : -1;
			}
			for (int i = 0; i < 8; ++i)
				if(vertFlagsBuf[i] != 0)
					vertFlags[i] = vertFlagsBuf[i];
		}
		for (int i = 0; i < 8; ++i) // Mark 3 neighbour vertexes
		{
			if (vertFlags[i] != 0)
				continue;
			int MarkedNeighNum = 0;
			for (int ii = 0; ii < 3; ++ii)
				MarkedNeighNum += (vertFlags[NeighbourVert[i][ii]] == 0 ? 0 : 1);
			if (MarkedNeighNum < 3)
				continue;
			int Flag = vertFlags[NeighbourVert[i][0]] + vertFlags[NeighbourVert[i][1]] + vertFlags[NeighbourVert[i][2]];
			vertFlags[i] = Flag > 0 ? 1 : -1;
		}
	}
	for (int i = 0; i < 12; ++i)
	{
		if (vertFlags[EdgeVert[i][0]] == vertFlags[EdgeVert[i][1]])
		{ // Ensure empty edge
			Edges[i] = UINT_MAX;
		}
	}
	for (int i = 0; i < 12; ++i)
	{
		if (vertFlags[EdgeVert[i][0]] != vertFlags[EdgeVert[i][1]] && GetEdge(i) == nullptr)
		{ // Ensure non empty edge 
			int FaceNum0 = EdgeFace[i][0];
			int FaceNum1 = EdgeFace[i][1]; // Faces incident to the edge
			int k0 = -1, k1 = -1; // Edges on incident faces 
			for (int k = 0; k < 12; ++k)
			{
				if (EdgeFace[k][0] == FaceNum0 || EdgeFace[k][0] == FaceNum1 || EdgeFace[k][1] == FaceNum0 || EdgeFace[k][1] == FaceNum1)
				{
					if (GetEdge(k) == nullptr)
						continue;
					if (k0 < 0)
						k0 = k;
					else
					{
						k1 = k;
						break;
					}
				}
			}
			if (k1 < 0)
			{
				//OutputDebugString("\n internal error ");
				return -1;//internal error
			}
			int Ind0 = GetEdge(k0)->GetPoint(), Ind1 = GetEdge(k1)->GetPoint(); // indexes in BUF
			float *Base0 = pBigCell->GetTriangleArea().GetAtNP(Ind0);
			float *Base1 = pBigCell->GetTriangleArea().GetAtNP(Ind1);
			BPoint Normal(0.5 * (Base0[0] + Base1[0]), 0.5 * (Base0[1] + Base1[1]), 0.5 * (Base0[2] + Base1[2]), 0.);
			double ND2 = Normal.D2();
			if (ND2 > 1e-8)
				Normal = Normal * (1. / sqrt(ND2));

			float Coord[3] = { 0., 0., 0. };
			Coord[Edge2Dir[i]] = float(0.5 * (Base0[3 + Edge2Dir[i]] + Base1[3 + Edge2Dir[i]]));
			// Get middle of edge
			switch (i)
			{
			case 0:
				Coord[1] = float(kY);
				Coord[2] = float(kZ);
				break;
			case 1:
				Coord[0] = float(kX + dX);
				Coord[2] = float(kZ);
				break;
			case 2:
				Coord[1] = float(kY + dY);
				Coord[2] = float(kZ);
				break;
			case 3:
				Coord[0] = float(kX);
				Coord[2] = float(kZ);
				break;
			case 4:
				Coord[1] = float(kY);
				Coord[2] = float(kZ + dZ);
				break;
			case 5:
				Coord[0] = float(kX + dX);
				Coord[2] = float(kZ + dZ);
				break;
			case 6:
				Coord[1] = float(kY + dY);
				Coord[2] = float(kZ + dZ);
				break;
			case 7:
				Coord[0] = float(kX);
				Coord[2] = float(kZ + dZ);
				break;
			case 8:
				Coord[0] = float(kX);
				Coord[1] = float(kY);
				break;
			case 9:
				Coord[0] = float(kX + dX);
				Coord[1] = float(kY);
				break;
			case 10:
				Coord[0] = float(kX);
				Coord[1] = float(kY + dY);
				break;
			case 11:
				Coord[0] = float(kX + dX);
				Coord[1] = float(kY + dY);
				break;
			}
			Map.MakeNewEdge(Edge2Dir[i], Coord, Normal, Edges[i], this);
		}
	}
	//OutputDebugString("\n");
	//for (int i = 0; i < 12; ++i)
	//{
	//	CString S;
	//	S.Format("%d ", EdgeCell[i]);
	//	OutputDebugString(S);
	//}
	//OutputDebugString("\n");
	//for (int i = 0; i < 8; ++i)
	//{
	//	CString S;
	//	S.Format("%d ", vertFlags[i]);
	//	OutputDebugString(S);
	//}
	return 0;
}

int DXCell5X::MakeTriangles(const DXCellInd &Key, const DXMap &Map)
{
	// Key is absolute i.e. its indexes must be relative to whole body but not for DXMap
	bool UseMC = BDebugState::Get().MarchCubes;
	// Find additional points on faces
	// Attach edge points to faces
	// We work with top 3 faces only (2, 3, 5 faces, (all edges except 0, 3, 8.
	if (!pBigCell)
		return -1;
	for (int Ci = 0; Ci < DXBigCell5X::MAX_FinalCycles; pBigCell->GetGData()->FinalCycles[Ci++].Clear());
	FillFaceResult Res = FF_0MAX;
	for (int i = 0; i < 12; ++i)
	{
		const DXEdge *pEdge = GetEdge(i);
		if (pEdge != nullptr)
			if (pEdge->GetDegraded() != 0)
			{
				Res = FF_FAILED;
				break;
			}
	}
	FEP FaceEdgeP;
	if (Res != FF_FAILED)
		Res = FillFaceEdgeP(FaceEdgeP, true);
	if (Res == FF_FAILED)
	{ // Try to recover
		if (!UseMC)
			return 0;
		if (RecoverWhenOnSurface(Key, Map) >= 0)
		{
			//HealCell(Key, FaceEdgeP);
			Res = FillFaceEdgeP(FaceEdgeP, true);
			//if (Res != FF_FAILED)
			//	Beep(3000, 1000);
			//else
			//	Beep(1000, 1000);
		}
	}
	if (Res == FF_0MAX)
	{
		return 0;
	}
	if (Res == FF_FAILED)
	{
//		Beep(3000, 10);
		Res = FF_0MAX;
		return 0;
	}
	if (GBodyRender::GetFindVergPoint())
		MakeAdditPoints(Key, FaceEdgeP);
	if (UseMC)
	{
		MakeFinalCycleMC();
	}
	else
	{
		switch(Res)
		{
		case FF_2PMAX:
			MakeFinalCycle(FaceEdgeP);
			break;
		case FF_4PMAX:
			MakeFinalCycle4(FaceEdgeP);
			break;
		}
	}

	for (int Ci = 0; Ci < DXBigCell5X::MAX_FinalCycles; ++Ci)
	{
		pBigCell->GetGData()->FinalCycle = pBigCell->GetGData()->FinalCycles[Ci];
		// Make triangles
		if(pBigCell->GetGData()->FinalCycle.GetSize() == 0)
			break;
		if(pBigCell->GetGData()->FinalCycle.GetSize() < 3)
			continue;
		switch(pBigCell->GetGData()->FinalCycle.GetTrueCount())
		{
		case 0:
			Store0();
			break;
		case 1:
			Store1(Key);
			break;
		case 2:
			Store2(Key);// One fan starting in the additional point		
			break;
		case 3:
			Store3(Key);
			break;
		case 4:
			Store4(Key);
			break;
		case 5:
			Store5(Key);
			break;
		case 6:
			Store6(Key);
			break;
		default:
			return 0;
	//		StoreSingleFan(Stride, Key);
			break;
		}
	}
	return 0;
}
void DXCell5X::Store0()
{
	// no additional point
	const DXEdge *pEdge = GetEdge(pBigCell->GetGData()->FinalCycle[0]);
	if (!pEdge)
		return;
	int posbuf = pEdge->GetPoint();
	int ind = posbuf;
	pEdge = GetEdge(pBigCell->GetGData()->FinalCycle[1]);
	if (!pEdge)
		return;
	int posbuf1 = pEdge->GetPoint();
	int ind1 = posbuf1; 
	for (int c = 1; c < pBigCell->GetGData()->FinalCycle.GetSize() - 1; ++c)
	{
		pEdge = GetEdge(pBigCell->GetGData()->FinalCycle[c + 1]);
		if (!pEdge)
			continue;
		int posbuf2 = pEdge->GetPoint();
		int ind2 = posbuf2;
	
		pBigCell->GetTriangleArea().AddTriInd(ind, ind1, ind2);// make triangle

		ind1 = ind2;
	}
}
void DXCell5X::StoreSingleFan(const DXCellInd &Key)
{
	// Find all additional points
	int AddPoints[6];
	int AddPointsNum = 0;
	for(int i = 0; i < pBigCell->GetGData()->FinalCycle.GetSize(); ++i)
		if (pBigCell->GetGData()->FinalCycle[i].BoundOrEdge)
			AddPoints[AddPointsNum++] = i;
	BPoint V[6]; //Ќаправл€ющие векторы рЄбер
	BPoint O[6]; // Points on edges
	int LinesNum = 0;
	for(unsigned char kk = 0; kk < AddPointsNum; ++kk)
	{
		const int *PointPos = GetBound(pBigCell->GetGData()->FinalCycle[AddPoints[kk]].Number)->GetPoint();
		float *N0 = pBigCell->GetTriangleArea().GetAtNP(PointPos[0]);
		float *N1 = pBigCell->GetTriangleArea().GetAtNP(PointPos[1]);
		V[kk] = BPoint(N0[0], N0[1], N0[2], 0.) % BPoint(N1[0], N1[1], N1[2], 0.);
		double VD = sqrt(V[kk].D2());
		if (VD < MIND)
			continue;
		V[kk] = V[kk] * (1. / VD);
		float *P = N0 + 3;
		O[kk].Set(P[0], P[1], P[2], 1.);
		++LinesNum;
	}
	BPoint *pO[6] = {O, O + 1, O + 2, O + 3, O + 4, O + 5};
	BPoint *pV[6] = {V, V + 1, V + 2, V + 3, V + 4, V + 5};
	BPoint NP(0., 0., 0., -1.);
	if(LinesNum == AddPointsNum)
		NP = BPoint::Nearest2LinesD(LinesNum, pO, pV);
	if (NP.IsPoint())
	{
		EnsureInCell(Key, NP);
		StoreSingleFan(NP, Key);
	}
	else
	{
		Store2(Key);
	}
}

void DXCell5X::StoreSingleFan(const BPoint &NP, const DXCellInd& Key)
{
	// строим треугольники поверхности------------------------------------------------
	int FCSize = pBigCell->GetGData()->FinalCycle.GetSize(); 
	int Prev = FCSize - 1;
	const DXBigCell5X::GroupData *pData = pBigCell->GetGData();
	for (int Cur = 0; Cur < FCSize; ++Cur)
	{
		int Next = (Cur + 1) % FCSize;
		// One vertex in each triangle is not bound vertex
		// This vertex surface should be used to calculate main (Index) point normal
		bool BoE = pData->FinalCycle[Cur].BoundOrEdge;
		int IndexX = BoE ? Next : Cur;
		const DXEdge *pEdge = GetEdge(pData->FinalCycle[IndexX]);
		ElemID MainSurfID = pEdge == nullptr ? 0 : pEdge->GetBaseID();

		StoreNPC(pBigCell->GetTriangleArea().GetNextNP(), NP, MainSurfID);
		int ind0 = pBigCell->GetTriangleArea().GetActSizeP() - 1;

  		int posbuf1;
		if (pData->FinalCycle[Cur].BoundOrEdge)
		{
			auto BoundInd = pData->FinalCycle[Cur].Number;
			pBigCell->GetSharpEdges().emplace_back(UINT_MAX, Bounds[BoundInd], Key, DXSharpEdge::noBound_, BoundInd);
			const int *PointsPair = GetBound(BoundInd)->GetPoint();
			posbuf1 = PointsPair[pData->FinalCycle[Next].Number < pData->FinalCycle[Prev].Number ? 0 : 1];
			DXSharpEdge& SharpEdge = pBigCell->GetSharpEdges().back();
			if (pBigCell->AddSharpEdge(ind0, PointsPair, SharpEdge))
				pBigCell->AddSharpInds2Bounds(SharpEdge);
			else
				pBigCell->GetSharpEdges().pop_back();
		}
		else 
			posbuf1 = GetBufNum(pBigCell->GetGData()->FinalCycle[Cur]);

		int posbuf2;
		if (pData->FinalCycle[Next].BoundOrEdge)
		{
			posbuf2 = GetBound(pData->FinalCycle[Next].Number)
				->GetPoint()[pData->FinalCycle[Cur].Number < pData->FinalCycle[(Next + 1) % FCSize].Number ? 0 : 1];
		}
		else 
			posbuf2 = GetBufNum(pData->FinalCycle[Next]);

		pBigCell->GetTriangleArea().AddTriInd(ind0, posbuf1, posbuf2);// создаем треугольники дл€ €чейки
		Prev = Cur;
	}
}
void DXCell5X::Store3(const DXCellInd &Key)
{
	if(pBigCell->GetGData()->FinalCycle.GetSize() < 3)
		return;
	StoreSingleFan(Key);
}

void DXCell5X::Store5(const DXCellInd &Key)
{
	StoreSingleFan(Key);
	return;
}

void DXCell5X::Store6(const DXCellInd &Key)
{
	StoreSingleFan(Key);
	return;
}

DXCell5X::FillFaceResult DXCell5X::FillFaceEdgeP(FEP FaceEdgeP, bool /*Check  = false*/) const
{
	EmptyFEP(FaceEdgeP);
	// We should ensure that the edge with the smaller number is processed before the another one
	int PointOnEdgeCount = 0;
	{const int e = 0;
		const DXEdge *pEdge = GetEdge(e);
		if(pEdge)
		{
			++PointOnEdgeCount;
			const int *Face = EdgeFace[e];
			int *P51 = FaceEdgeP[Face[0]];
			int *P52 = FaceEdgeP[Face[1]];
			if (P51[PC] >= 4 || P52[PC] >= 4) // Check for safety
				return FF_FAILED;
			P51[P51[PC] + EN] = P52[P52[PC] + EN] = e;
			++P51[PC];
			++P52[PC];
		}
	}
	{const int e = 1;
		const DXEdge *pEdge = GetEdge(e);
		if (pEdge)
		{
			++PointOnEdgeCount;
			const int *Face = EdgeFace[e];
			int *P51 = FaceEdgeP[Face[0]];
			int *P52 = FaceEdgeP[Face[1]];
			if (P51[PC] >= 4 || P52[PC] >= 4) // Check for safety
				return FF_FAILED;
			P51[P51[PC] + IiB] = pEdge->GetPoint();
			P51[P51[PC] + ID] = pEdge->GetBaseID();
			P51[P51[PC] + EN] = P52[P52[PC] + EN] = e;
			++P51[PC];
			++P52[PC];
		}
	}
	{const int e = 2;
		const DXEdge *pEdge = GetEdge(e);
		if (pEdge)
		{
			++PointOnEdgeCount;
			const int *Face = EdgeFace[e];
			int *P51 = FaceEdgeP[Face[0]];
			int *P52 = FaceEdgeP[Face[1]];
			if (P51[PC] >= 4 || P52[PC] >= 4) // Check for safety
				return FF_FAILED;
			P52[P52[PC] + IiB] = pEdge->GetPoint();
			P52[P52[PC] + ID] = pEdge->GetBaseID();
			P51[P51[PC] + EN] = P52[P52[PC] + EN] = e;
			++P51[PC];
			++P52[PC];
		}
	}
	{const int e = 3;
		const DXEdge *pEdge = GetEdge(e);
		if (pEdge)
		{
			++PointOnEdgeCount;
			const int *Face = EdgeFace[e];
			int *P51 = FaceEdgeP[Face[0]];
			int *P52 = FaceEdgeP[Face[1]];
			if (P51[PC] >= 4 || P52[PC] >= 4) // Check for safety
				return FF_FAILED;
			P51[P51[PC] + EN] = P52[P52[PC] + EN] = e;
			++P51[PC];
			++P52[PC];
		}
	}
	{const int e = 4;
		const DXEdge *pEdge = GetEdge(e);
		if (pEdge)
		{
			++PointOnEdgeCount;
			const int *Face = EdgeFace[e];
			int *P51 = FaceEdgeP[Face[0]];
			int *P52 = FaceEdgeP[Face[1]];
			if (P51[PC] >= 4 || P52[PC] >= 4) // Check for safety
				return FF_FAILED;
			P51[P51[PC] + IiB] = pEdge->GetPoint();
			P51[P51[PC] + ID] = pEdge->GetBaseID();
			P51[P51[PC] + EN] = P52[P52[PC] + EN] = e;
			++P51[PC];
			++P52[PC];
		}
	}
	{const int e = 5;
		const DXEdge *pEdge = GetEdge(e);
		if (pEdge)
		{
			++PointOnEdgeCount;
			const int *Face = EdgeFace[e];
			int *P51 = FaceEdgeP[Face[0]];
			int *P52 = FaceEdgeP[Face[1]];
			if (P51[PC] >= 4 || P52[PC] >= 4) // Check for safety
				return FF_FAILED;
			P51[P51[PC] + IiB] = P52[P52[PC] + IiB] = pEdge->GetPoint();
			P51[P51[PC] + ID] = P52[P52[PC] + ID] = pEdge->GetBaseID();
			P51[P51[PC] + EN] = P52[P52[PC] + EN] = e;
			++P51[PC];
			++P52[PC];
		}
	}
	{const int e = 6;
		const DXEdge *pEdge = GetEdge(e);
		if (pEdge)
		{
			++PointOnEdgeCount;
			const int *Face = EdgeFace[e];
			int *P51 = FaceEdgeP[Face[0]];
			int *P52 = FaceEdgeP[Face[1]];
			if (P51[PC] >= 4 || P52[PC] >= 4) // Check for safety
				return FF_FAILED;
			P51[P51[PC] + IiB] = P52[P52[PC] + IiB] = pEdge->GetPoint();
			P51[P51[PC] + ID] = P52[P52[PC] + ID] = pEdge->GetBaseID();
			P51[P51[PC] + EN] = P52[P52[PC] + EN] = e;
			++P51[PC];
			++P52[PC];
		}
	}
	{const int e = 7;
		const DXEdge *pEdge = GetEdge(e);
		if (pEdge)
		{
			++PointOnEdgeCount;
			const int *Face = EdgeFace[e];
			int *P51 = FaceEdgeP[Face[0]];
			int *P52 = FaceEdgeP[Face[1]];
			if (P51[PC] >= 4 || P52[PC] >= 4) // Check for safety
				return FF_FAILED;
			P52[P52[PC] + IiB] = pEdge->GetPoint();
			P52[P52[PC] + ID] = pEdge->GetBaseID();
			P51[P51[PC] + EN] = P52[P52[PC] + EN] = e;
			++P51[PC];
			++P52[PC];
		}
	}
	{const int e = 8;
		const DXEdge *pEdge = GetEdge(e);
		if (pEdge)
		{
			++PointOnEdgeCount;
			const int *Face = EdgeFace[e];
			int *P51 = FaceEdgeP[Face[0]];
			int *P52 = FaceEdgeP[Face[1]];
			if (P51[PC] >= 4 || P52[PC] >= 4) // Check for safety
				return FF_FAILED;
			P51[P51[PC] + EN] = P52[P52[PC] + EN] = e;
			++P51[PC];
			++P52[PC];
		}
	}
	{const int e = 9;
		const DXEdge *pEdge = GetEdge(e);
		if (pEdge)
		{
			++PointOnEdgeCount;
			const int *Face = EdgeFace[e];
			int *P51 = FaceEdgeP[Face[0]];
			int *P52 = FaceEdgeP[Face[1]];
			if (P51[PC] >= 4 || P52[PC] >= 4) // Check for safety
				return FF_FAILED;
			P52[P52[PC] + IiB] = pEdge->GetPoint();
			P52[P52[PC] + ID] = pEdge->GetBaseID();
			P51[P51[PC] + EN] = P52[P52[PC] + EN] = e;
			++P51[PC];
			++P52[PC];
		}
	}
	{const int e = 10;
		const DXEdge *pEdge = GetEdge(e);
		if (pEdge)
		{
			++PointOnEdgeCount;
			const int *Face = EdgeFace[e];
			int *P51 = FaceEdgeP[Face[0]];
			int *P52 = FaceEdgeP[Face[1]];
			if (P51[PC] >= 4 || P52[PC] >= 4) // Check for safety
				return FF_FAILED;
			P51[P51[PC] + IiB] = pEdge->GetPoint();
			P51[P51[PC] + ID] = pEdge->GetBaseID();
			P51[P51[PC] + EN] = P52[P52[PC] + EN] = e;
			++P51[PC];
			++P52[PC];
		}
	}
	{const int e = 11;
		const DXEdge *pEdge = GetEdge(e);
		if (pEdge)
		{
			++PointOnEdgeCount;
			const int *Face = EdgeFace[e];
			int *P51 = FaceEdgeP[Face[0]];
			int *P52 = FaceEdgeP[Face[1]];
			if (P51[PC] >= 4 || P52[PC] >= 4) // Check for safety
				return FF_FAILED;
			P51[P51[PC] + IiB] = P52[P52[PC] + IiB] = pEdge->GetPoint();
			P51[P51[PC] + ID] = P52[P52[PC] + ID] = pEdge->GetBaseID();
			P51[P51[PC] + EN] = P52[P52[PC] + EN] = e;
			++P51[PC];
			++P52[PC];
		}
	}
	if (PointOnEdgeCount < 3)
		return FF_0MAX;
	FillFaceResult Res = FF_2PMAX;
	for(int f = 0; f < 6; ++f)
	{
		if(FaceEdgeP[f][PC] == 1 || FaceEdgeP[f][PC] == 3)
			return FF_FAILED;
		if(FaceEdgeP[f][PC] == 4)
			Res = FF_4PMAX;
	}
	return Res;
}

bool DXCell5X::FindBoundPoint(int LocalFaceNum, const int *EdgeP, BPoint &BoundP)
{
	static const int FaceBUFShifts[3][5] = {{4, 5, 3, 1, 2}, {3, 5, 4, 0, 2}, {3, 4, 5, 0, 1}};
	static const int FaceCoords[3][3] = {{1, 2, 0}, {0, 2, 1}, {0, 1, 2}};
	const int *BUFShifts = FaceBUFShifts[LocalFaceNum]; // Corresponds to global faces 2,3,5
	const int *Coords = FaceCoords[LocalFaceNum];
	float *Base0 = pBigCell->GetTriangleArea().GetAtNP(EdgeP[IiB]);
	float *Base1 = pBigCell->GetTriangleArea().GetAtNP(EdgeP[IiB + 1]);

	double CosA2 = Base0[0] * Base1[0] + Base0[1] * Base1[1] + Base0[2] * Base1[2];
	double N0D2 = Base0[0] * Base0[0] + Base0[1] * Base0[1] + Base0[2] * Base0[2];
	double N1D2 = Base1[0] * Base1[0] + Base1[1] * Base1[1] + Base1[2] * Base1[2];
	CosA2 = CosA2 * CosA2 / (N0D2 * N1D2);
	if (CosA2 > 1. - GBodyRender::GetMinSin2())
		return false; // Real (3D) normals are parallel. Surface is smooth

	float * BPoint0 = Base0;
	float * BPoint1 = Base1;

	float BPoints[2][6]; // Nx, Ny, Nz, X, Y, Z
	int Iterations = GBodyRender::GetDichotDegree();
	if (GBodyRender::GetDichotDegree() > 0)
	{
		MElemIDProc *pProc = MFOREST.GetIDProc();
		SOrigSurf *pSurf0 = NULL;
		int SurfNum0 = pProc->GetSurfID(EdgeP[ID]);
		if(SurfNum0 >= 0 && SurfNum0 != ID_EMPTY)
			pSurf0 = MFOREST.GetOrigSurf(SurfNum0);
		SOrigSurf *pSurf1 = NULL;
		int SurfNum1 = pProc->GetSurfID(EdgeP[ID + 1]);
		if(SurfNum1 >= 0 && SurfNum1 != ID_EMPTY)
			pSurf1 = MFOREST.GetOrigSurf(SurfNum1);
		if(pSurf0 != NULL && pSurf1 != NULL)
		{
			BPoint P0(Base0[3], Base0[4], Base0[5], 1);
			BPoint P1(Base1[3], Base1[4], Base1[5], 1);
			BPoint RDir(Base0[0] + Base1[0], Base0[1] + Base1[1], Base0[2] + Base1[2], 0.); // external normals assumed
			RDir[Coords[2]] = 0.; // Project to the plane of the face
			for(int k = 0; k < Iterations; ++k) 
			{
				BPoint Center((P0 + P1) * 0.5);
				BPoint Center2(Center);
				
				
				bool Lf = pSurf0->RefiningPoint(Center, RDir);
				bool Rf = pSurf1->RefiningPoint(Center2, RDir);
				if(!Lf && !Rf)
					break; //≈сли внезапно нас накрыл страшный глюк
				if(!Lf) // Ensure absent surface is upper
					Center += RDir * 1.e6;
				if(!Rf)
					Center2 += RDir * 1.e6;
				if(Center * RDir < Center2 * RDir) //—двиг границы в середину
					P0 = Center;
				else
					P1 = Center2;
			}
			// Prepare data for IntersectionPoint
			BPoint0 = BPoints[0];
			BPoint0[3] = float(P0.GetX());
			BPoint0[4] = float(P0.GetY());
			BPoint0[5] = float(P0.GetZ());
			pSurf0->GetNormalFast(BPoint0);
			BPoint1 = BPoints[1];
			BPoint1[3] = float(P1.GetX());
			BPoint1[4] = float(P1.GetY());
			BPoint1[5] = float(P1.GetZ());
			pSurf1->GetNormalFast(BPoint1);
		}
	}
	CosA2 = BPoint0[0] * BPoint1[0] + BPoint0[1] * BPoint1[1] + BPoint0[2] * BPoint1[2];
	N0D2 = BPoint0[0] * BPoint0[0] + BPoint0[1] * BPoint0[1] + BPoint0[2] * BPoint0[2];
	N1D2 = BPoint1[0] * BPoint1[0] + BPoint1[1] * BPoint1[1] + BPoint1[2] * BPoint1[2];
	CosA2 = CosA2 * CosA2 / (N0D2 * N1D2);
	if (CosA2 > 1. - GBodyRender::GetMinSin2())// New test after refining
		return false; // Real (3D) normals are parallel. Surface is smooth
	double Val[3];
	if(!IntersectionPoint(&Val[Coords[0]], &Val[Coords[1]], BPoint0, BPoint1, BUFShifts))
		return false;
	// Check point position
	if(!CheckPointOnFace(Base0, Val, LocalFaceNum, EdgeP[EN]))
		return false;
	if(!CheckPointOnFace(Base1, Val, LocalFaceNum, EdgeP[EN + 1]))
		return false;
	Val[Coords[2]] = *(Base0 + BUFShifts[2]);
	BoundP.Set(Val[0], Val[1], Val[2], 1.);
	return true;
}

void DXCell5X::StoreNPC(float *BUF, const BPoint &P, ElemID iID)
{
	BUF[3] = float(P.GetX());
	BUF[4] = float(P.GetY());
	BUF[5] = float(P.GetZ());
	StoreNPC(BUF, iID, *pBigCell->GetGData());
}

void DXCell5X::StoreNPC(float *BUF, ElemID iID, DXBigCell5X::GroupData &GData)
{
	MElemIDProc *pProc = MFOREST.GetIDProc();
	int PCNum = pProc->GetPCn(iID);
	int SurfNum = pProc->GetSurfID(iID);
	if(SurfNum < 0)
	{
		pProc->GetNormalFromSurfID(SurfNum, BUF);
	}
	else
	{
		SOrigSurf *pSurf = MFOREST.GetOrigSurf(SurfNum);
		if(!pSurf)
		{
			*(BUF) = 0.;
			*(BUF + 1) = 0.;
			*(BUF + 2) = -1.;
		}
		else
			pSurf->GetNormalFast(BUF);
	}
	if(GData.PrevPCNum != PCNum)// This trick is for speed up only
	{
		GData.PrevPCNum = PCNum;
		GData.PrevColor = pProc->GetColor(iID);
	}
	*(BUF + 6) = GData.PrevColor.fval;
}

void DXCell5X::StoreNPC(float *BUF, const BPoint &P, const BPoint &N)
{
	*(BUF) = float(-N.GetX());
	*(BUF + 1) = float(-N.GetY());
	*(BUF + 2) = float(-N.GetZ());
    *(BUF + 3) = float(P.GetX());
	*(BUF + 4) = float(P.GetY());
	*(BUF + 5) = float(P.GetZ());
	*(BUF + 6) = pBigCell->GetGData()->PrevColor.fval;
}

void DXCell5X::StoreNPC(float *BUF, float *P, const BPoint &N)
{
	*(BUF) = float(-N.GetX());
	*(BUF + 1) = float(-N.GetY());
	*(BUF + 2) = float(-N.GetZ());
    *(BUF + 3) = P[0];
	*(BUF + 4) = P[1];
	*(BUF + 5) = P[2];
	*(BUF + 6) = pBigCell->GetGData()->PrevColor.fval;
}

bool DXCell5X::CheckPointOnFace(float * Base, double Val[3], int LocalFaceNum, int EdgeNum)
{
	return true;
	//switch(EdgeNum)
	//{
	//	case 1:
	//	case 2:
	//		if(Val[2] > Base[5] + pBigCell->GetGData()->StepZ)
	//			Val[2] = Base[5] + pBigCell->GetGData()->StepZ;
	//		return Val[2] > Base[5]; 
	//	case 4:
	//	case 9:
	//		if(Val[1] > Base[4] + pBigCell->GetGData()->StepY)
	//			Val[1] = Base[4] + pBigCell->GetGData()->StepY;
	//		return Val[1] > Base[4]; 
	//	case 7:
	//	case 10:
	//		if(Val[0] > Base[3] + pBigCell->GetGData()->StepX)
	//			Val[0] = Base[3] + pBigCell->GetGData()->StepX;
	//		return Val[0] > Base[3]; 
	//}
	//switch(LocalFaceNum)
	//{
	//case 0:
	//	switch(EdgeNum)
	//	{
	//	case 5:
	//		if(Val[2] < Base[5] - pBigCell->GetGData()->StepZ)
	//			Val[2] = Base[5] - pBigCell->GetGData()->StepZ;
	//		return Val[2] < Base[5]; 
	//	case 11:
	//		if(Val[1] < Base[4] - pBigCell->GetGData()->StepY)
	//			Val[1] = Base[4] - pBigCell->GetGData()->StepY;
	//		return Val[1] < Base[4]; 
	//	}
	//	return false;
	//case 1:
	//	switch(EdgeNum)
	//	{
	//	case 6:
	//		if(Val[2] < Base[5] - pBigCell->GetGData()->StepZ)
	//			Val[2] = Base[5] - pBigCell->GetGData()->StepZ;
	//		return Val[2] < Base[5]; 
	//	case 11:
	//		if(Val[0] < Base[3] - pBigCell->GetGData()->StepX)
	//			Val[0] = Base[3] - pBigCell->GetGData()->StepX;
	//		return Val[0] < Base[3]; 
	//	}
	//	return false;
	//case 2:
	//	switch(EdgeNum)
	//	{
	//	case 5:
	//		if(Val[0] < Base[3] - pBigCell->GetGData()->StepX)
	//			Val[0] = Base[3] - pBigCell->GetGData()->StepX;
	//		return Val[0] < Base[3]; 
	//	case 6:
	//		if(Val[1] < Base[4] - pBigCell->GetGData()->StepY)
	//			Val[1] = Base[4] - pBigCell->GetGData()->StepY;
	//		return Val[1] < Base[4]; 
	//	}
	//	return false;
	//}
	//return false;
}

bool DXCell5X::IsInCell(const DXCellInd &Key, BPoint &P)
{
	double X, Y, Z, H;
	P.Get(X, Y, Z, H);
	double kX = Key.Ix * pBigCell->GetGData()->StepX + pBigCell->GetGData()->MinPointShift.GetX();
	double kY = Key.Iy * pBigCell->GetGData()->StepY + pBigCell->GetGData()->MinPointShift.GetY();
	double kZ = Key.Iz * pBigCell->GetGData()->StepZ + pBigCell->GetGData()->MinPointShift.GetZ();
	
	if (!(X < kX || X > kX + pBigCell->GetGData()->StepX || Y < kY || Y > kY + pBigCell->GetGData()->StepY || Z < kZ || Z > kZ + pBigCell->GetGData()->StepZ))
		return true;
	return false;
}

bool DXCell5X::EnsureInCell(const DXCellInd &Key, BPoint &P)
{
	double X, Y, Z, H;
	P.Get(X, Y, Z, H);
	double kX = Key.Ix * pBigCell->GetGData()->StepX + pBigCell->GetGData()->MinPointShift.GetX();
	double kY = Key.Iy * pBigCell->GetGData()->StepY + pBigCell->GetGData()->MinPointShift.GetY();
	double kZ = Key.Iz * pBigCell->GetGData()->StepZ + pBigCell->GetGData()->MinPointShift.GetZ();
	// провер€ем попала ли точка в пределы €чейки
	if (!(X < kX || X > kX + pBigCell->GetGData()->StepX || Y < kY || Y > kY + pBigCell->GetGData()->StepY || Z < kZ || Z > kZ + pBigCell->GetGData()->StepZ))
		return true;
				
	{
		//прит€гиваем по нормали 
		if (X < kX)
			X = kX;
		else if (X > kX + pBigCell->GetGData()->StepX)
			X = kX + pBigCell->GetGData()->StepX;
		if (Y < kY)
			Y = kY;
		else if (Y > kY + pBigCell->GetGData()->StepY)
			Y = kY + pBigCell->GetGData()->StepY;
		if (Z < kZ)
			Z = kZ;
		else if (Z > kZ + pBigCell->GetGData()->StepZ)
			Z = kZ + pBigCell->GetGData()->StepZ;
	}
	P.Set(X, Y, Z, H);
	return false;
}

void DXCell5X::Store1(const DXCellInd& Key)
{
	Store2(Key);
}

void DXCell5X::Store2(const DXCellInd& Key)
{
	int First = pBigCell->GetGData()->FinalCycle.FirstTrue(); // First additional point ( always > 0)
	Store4_1Fan(First, First, Key);
}

void DXCell5X::Store4_1Fan(int First, int Stop, const DXCellInd& Key)
{
	int FCSize = pBigCell->GetGData()->FinalCycle.GetSize(); 
	const int *FirstPosbufs = GetBound(pBigCell->GetGData()->FinalCycle[First].Number)->GetPoint();
	int PrevEdge = pBigCell->GetGData()->FinalCycle[First - 1].Number; // First can not be 0
	int Cur = (First + 1) % FCSize;
	int NextEdge = pBigCell->GetGData()->FinalCycle[Cur].Number;
	bool FirstFirstNormal = (PrevEdge > NextEdge);
	const DXBigCell5X::GroupData *pData = pBigCell->GetGData();
	int Prev = First;
	for(int Next = (Cur + 1) % FCSize; Next != Stop; Next = (Next + 1) % FCSize) // First half
	{
		int posbuf1;
		if (pBigCell->GetGData()->FinalCycle[Cur].BoundOrEdge)
		{
			FirstFirstNormal = !FirstFirstNormal;

			auto CurBoundInd = pData->FinalCycle[Cur].Number;
			auto FirstBoundInd = pData->FinalCycle[First].Number;
			pBigCell->GetSharpEdges().emplace_back(Bounds[FirstBoundInd], Bounds[CurBoundInd], Key, FirstBoundInd, CurBoundInd);
			const int* PointsPair = GetBound(CurBoundInd)->GetPoint();
			posbuf1 = PointsPair[pData->FinalCycle[Next].Number < pData->FinalCycle[Prev].Number ? 0 : 1];
			DXSharpEdge& SharpEdge = pBigCell->GetSharpEdges().back();
			if (pBigCell->AddSharpEdge(FirstPosbufs, PointsPair, SharpEdge))
				pBigCell->AddSharpInds2Bounds(SharpEdge);
			else
				pBigCell->GetSharpEdges().pop_back();
		}
		else 
			posbuf1 = GetBufNum(pBigCell->GetGData()->FinalCycle[Cur]);

		int posbuf2;
		if (pBigCell->GetGData()->FinalCycle[Next].BoundOrEdge)
		{
			posbuf2 = GetBound(pBigCell->GetGData()->FinalCycle[Next].Number)
				->GetPoint()[pBigCell->GetGData()->FinalCycle[Cur].Number < pBigCell->GetGData()->FinalCycle[(Next + 1) % FCSize].Number ? 0 : 1];
		}
		else 
			posbuf2 = GetBufNum(pBigCell->GetGData()->FinalCycle[Next]);

						
		int ind = FirstPosbufs[FirstFirstNormal ? 0 : 1];
		int ind1 = posbuf1;
		int ind2 = posbuf2;
		pBigCell->GetTriangleArea().AddTriInd(ind, ind1, ind2);// создаем треугольники дл€ €чейки
		Prev = Cur;
		Cur = Next;
	}
}

void DXCell5X::Store4(const DXCellInd& Key)
{
	// Find all additional points
	int AddPoints[4] = { 0, 0, 0, 0 };
	for(int i = 0, k = 0; i < pBigCell->GetGData()->FinalCycle.GetSize(); ++i)
		if (pBigCell->GetGData()->FinalCycle[i].BoundOrEdge)
			AddPoints[k++] = i;
	// Find additional points correspondence
	BPoint V[4]; //Ќаправл€ющие векторы рЄбер
	BPoint R[4]; // Vectors connecting consequitive pairs of verges
	bool AllAnglesBig = true;
	const double MinBigAngle2 = GBodyRender::GetMinSin2() * 100.;
	double AngleSin2[4];
	for(unsigned char kk = 0; kk < 4; ++kk)
	{
		const int *PointPos = GetBound(pBigCell->GetGData()->FinalCycle[AddPoints[kk]].Number)->GetPoint();
		float *N0 = pBigCell->GetTriangleArea().GetAtNP(PointPos[0]);
		float *N1 = pBigCell->GetTriangleArea().GetAtNP(PointPos[1]);
		V[kk] = BPoint(N0[0], N0[1], N0[2], 0.) % BPoint(N1[0], N1[1], N1[2], 0.);
		AngleSin2[kk] = V[kk].D2();
		AllAnglesBig = AllAnglesBig && (AngleSin2[kk] > MinBigAngle2);
		V[kk] = V[kk] * (1. / sqrt(AngleSin2[kk]));
		float *P = N0 + 3;
		const int *NextPointPos = GetBound(pBigCell->GetGData()->FinalCycle[AddPoints[(kk + 1) % 4]].Number)->GetPoint();
		float *PNext = pBigCell->GetTriangleArea().GetAtNP(NextPointPos[0]) + 3;
		R[kk].Set(PNext[0] - P[0], PNext[1] - P[1], PNext[2] - P[2], 0.);
		R[kk] = R[kk] * (1. / sqrt(R[kk].D2()));
	}
	double C0Next = fabs(V[0] * R[0]);
	double C0Prev = fabs(V[0] * R[3]);
	double C1Next = fabs(V[1] * R[1]);
	double C1Prev = fabs(V[1] * R[0]);
	double C2Next = fabs(V[2] * R[2]);
	double C2Prev = fabs(V[2] * R[1]);
	double C3Next = fabs(V[3] * R[3]);
	double C3Prev = fabs(V[3] * R[2]);
	bool NextPref0 = C0Next > C0Prev;
	bool NextPref1 = C1Next > C1Prev;
	bool NextPref2 = C2Next > C2Prev;
	bool NextPref3 = C3Next > C3Prev;
	// Determine which pair is better
	int D02 = (NextPref0 ? 1 : 0) + ((!NextPref1) ? 1 : 0) + (NextPref2 ? 1 : 0) + ((!NextPref3) ? 1 : 0);
	bool E02 = false;
	bool E13 = false;
	if(D02 > 2)
		E02 = true;
	else if(D02 < 2)
		E13 = true;
	if(!AllAnglesBig && (E02 || E13) )
	{// two independent edges
		int FirstAdd = E02 ? 0 : 1;
		Store4_1Fan(AddPoints[FirstAdd], (AddPoints[FirstAdd + 2] + 1) % pBigCell->GetGData()->FinalCycle.GetSize(), Key);
		Store4_1Fan(AddPoints[FirstAdd + 2], (AddPoints[FirstAdd] + 1) % pBigCell->GetGData()->FinalCycle.GetSize(), Key);
	}
	else
	{// one "main" edge
		// find two main face points
		StoreOneMainEdge(4, AddPoints, AngleSin2, Key);
	}
}

void DXCell5X::StoreOneMainEdge(int Count, int AddPoints[12], double AngleSin2[12], const DXCellInd& Key)
{
	// find two main face points
	int MainPts[2]; // Indexes in AddPoints
	double MainPtsWeight[2];
	if(AngleSin2[0] > AngleSin2[1])
	{
		MainPts[0] = 1;
		MainPts[1] = 0;
		MainPtsWeight[0] = AngleSin2[1];
		MainPtsWeight[1] = AngleSin2[0];
	}
	else
	{
		MainPts[0] = 0;
		MainPts[1] = 1;
		MainPtsWeight[0] = AngleSin2[0];
		MainPtsWeight[1] = AngleSin2[1];
	}
	for(int i = 2; i < Count; ++i)
	{
		double A = AngleSin2[i];
		if(A > MainPtsWeight[1])
		{
			MainPtsWeight[0] = MainPtsWeight[1];
			MainPtsWeight[1] = A;
			MainPts[0] = MainPts[1];
			MainPts[1] = i;
		}
		else if(A > MainPtsWeight[0])
		{
			MainPtsWeight[0] = A;
			MainPts[0] = i;
		}
	}
	// make triangles
	// Ensure MainPts[0] < MainPts[1]
	if(MainPts[0] > MainPts[1])
	{
		int b = MainPts[0];  MainPts[0] = MainPts[1]; MainPts[1] = b;
	}
	int First = AddPoints[MainPts[0]];
	int Stop = First;
	// Same as Store2 but FirstFirstNormal is processed different
	int FCSize = pBigCell->GetGData()->FinalCycle.GetSize(); 
	const int *FirstPosbufs = GetBound(pBigCell->GetGData()->FinalCycle[First].Number)->GetPoint();
	int PrevEdge = pBigCell->GetGData()->FinalCycle[First - 1].Number; // First can not be 0
	int Cur = (First + 1) % FCSize;
	int NextEdge = pBigCell->GetGData()->FinalCycle[Cur].Number;
	bool FirstFirstNormal = (PrevEdge > NextEdge);
	const DXBigCell5X::GroupData *pData = pBigCell->GetGData();
	int Prev = First;
	for(int Next = (Cur + 1) % FCSize; Next != Stop; Next = (Next + 1) % FCSize) // First half
	{
		int posbuf1;
		if (pBigCell->GetGData()->FinalCycle[Cur].BoundOrEdge)
		{
			if(Cur == AddPoints[MainPts[1]])
				FirstFirstNormal = !FirstFirstNormal;

			auto CurBoundInd = pData->FinalCycle[Cur].Number;
//TODO		auto FirstBoundInd = pData->FinalCycle[First].Number;
//TODO		pBigCell->GetSharpEdges().emplace_back(Bounds[FirstBoundInd], Bounds[CurBoundInd], Key, FirstBoundInd, CurBoundInd);
			const int* PointsPair = GetBound(CurBoundInd)->GetPoint();
			posbuf1 = PointsPair[pData->FinalCycle[Next].Number < pData->FinalCycle[Prev].Number ? 0 : 1];
//TODO			DXSharpEdge& SharpEdge = pBigCell->GetSharpEdges().back();
			//TODO if (pBigCell->AddSharpEdge(FirstPosbufs, PointsPair, SharpEdge))
			//TODO	pBigCell->AddSharpInds2Bounds(SharpEdge);
			//TODO else
			//TODO	pBigCell->GetSharpEdges().pop_back();
		}
		else 
			posbuf1 = GetBufNum(pBigCell->GetGData()->FinalCycle[Cur]);

		int posbuf2;
		if (pBigCell->GetGData()->FinalCycle[Next].BoundOrEdge)
		{
			posbuf2 = GetBound(pBigCell->GetGData()->FinalCycle[Next].Number)
				->GetPoint()[pBigCell->GetGData()->FinalCycle[Cur].Number < pBigCell->GetGData()->FinalCycle[(Next + 1) % FCSize].Number ? 0 : 1];
		}
		else 
			posbuf2 = GetBufNum(pBigCell->GetGData()->FinalCycle[Next]);

		int ind = FirstPosbufs[FirstFirstNormal ? 0 : 1];
		int ind1 = posbuf1;
		int ind2 = posbuf2;
		pBigCell->GetTriangleArea().AddTriInd(ind, ind1, ind2);// создаем треугольники дл€ €чейки
		Prev = Cur;
		Cur = Next;
	}
}

int DXCell5X::MakeFinalCycle4(FEP FaceEdgeP)
{
	// Additional point can be the last point in the FinalCycle but can't be the first point
	// Find first edge with the point
	bool EdgeFree[12] = { true, true, true, true, true, true, true, true, true, true, true, true };
	int PointOnEdgeCount = 0;
	for(int i = 0; i < 6; ++i)
		PointOnEdgeCount += FaceEdgeP[i][PC];
	int Ci = 0;
	for (; Ci < DXBigCell5X::MAX_FinalCycles && PointOnEdgeCount > 0; ++Ci)
	{
		pBigCell->GetGData()->FinalCycle = pBigCell->GetGData()->FinalCycles[Ci];
		int CurEdge = 0;
		const DXEdge *pFirst = NULL;
		for (; CurEdge < 12 ; ++CurEdge)
		{
			if (!EdgeFree[CurEdge])
				continue;
			if ((pFirst = GetEdge(CurEdge)) != NULL)
				break;
		}
		if(CurEdge >= 12)
			return Ci;
		// Find first face
		int FirstFace = (pFirst->GetRout()) ?// the beginning of the edge is occupied
				EdgeFace[CurEdge][1] : // right 
				EdgeFace[CurEdge][0]; // left
		// Make cycle
		int NextEdge;
		int CurFace = FirstFace;
		do
		{
			pBigCell->GetGData()->FinalCycle.PutBack(CurEdge, false);
			if(FaceEdgeP[CurFace][PC] == 4)
			{
				FaceEdgeP[CurFace][PC] = 2;
				if(FaceEdgeP[CurFace][EN] == CurEdge)
				{
					NextEdge = FaceEdgeP[CurFace][EN + 1];
					FaceEdgeP[CurFace][EN] = FaceEdgeP[CurFace][EN + 2];
					FaceEdgeP[CurFace][EN + 1] = FaceEdgeP[CurFace][EN + 3];
				}
				else if(FaceEdgeP[CurFace][EN + 1] == CurEdge)
				{
					NextEdge = FaceEdgeP[CurFace][EN];
					FaceEdgeP[CurFace][EN] = FaceEdgeP[CurFace][EN + 2];
					FaceEdgeP[CurFace][EN + 1] = FaceEdgeP[CurFace][EN + 3];
				}
				else if(FaceEdgeP[CurFace][EN + 2] == CurEdge)
					NextEdge = FaceEdgeP[CurFace][EN + 3];
				else
					NextEdge = FaceEdgeP[CurFace][EN + 2];
			}
			else
			{
				NextEdge = FaceEdgeP[CurFace][(FaceEdgeP[CurFace][EN] == CurEdge) ? EN + 1 : EN];
			}
			if (GetBound(CurFace) != NULL)// if CurFace contains additional point
				pBigCell->GetGData()->FinalCycle.PutBack(CurFace, true);
			CurFace = EdgeFace[NextEdge][(EdgeFace[NextEdge][0] == CurFace) ? 1 : 0];
			CurEdge = NextEdge;
			EdgeFree[CurEdge] = false;
		}
		while(CurFace != FirstFace);
		PointOnEdgeCount -= 2 * pBigCell->GetGData()->FinalCycle.GetSize();
	}
	return Ci;
}

int DXCell5X::MakeFinalCycleMC()
{
	// Additional point can be the last point in the FinalCycle but can't be the first point
	// Marching cubes modified by adding face numbers
	// http://paulbourke.net/geometry/polygonise/
	// 


	// Calculate main index
	
	const int Nodes[12][2] = { { 3, 2 }, { 2, 1 }, { 0, 1 }, { 3, 0 },
								{ 7, 6 }, { 6, 5 }, { 4, 5 }, { 7, 4 },
								{ 3, 7 }, { 2, 6 }, { 0, 4 }, { 1, 5 }};// My edge index to MC nodes indexes
	const int bEdges[12] = { 2, 1, 0, 3, 6, 5, 4, 7, 10, 11, 9, 8};// MC edge index to my edge index
	int main[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
	for (int e = 0; e < 12; ++e)
	{
		const DXEdge *pEdge = GetEdge(e);
		if (pEdge)
		{
			int side = pEdge->GetRout() ? 0 : 1;
			int NegativeIndex = Nodes[e][1 - side];
			int PositiveIndex = Nodes[e][side];
			if (main[NegativeIndex] > 0 || main[PositiveIndex] < 0)
			{
//				Beep(500, 1000);
				return -1; // contradictory mark
			}
			main[NegativeIndex] = -1;
			main[PositiveIndex] = 1;
		}
	}
	for (int k = 0; k < 3; ++k) // 3 is the length of the maximal path from one node to another one
	// Can be faster
	{
		for (int e = 0; e < 12; ++e)
		{ //if the edge don't have a point and one its end is marked, mark another end of this edge
			const DXEdge *pEdge = GetEdge(e);
			if (!pEdge)
			{
				if (main[Nodes[e][0]] != 0)
				{
					if (main[Nodes[e][1]] != 0 && main[Nodes[e][1]] != main[Nodes[e][0]])
					{
//						Beep(500, 1000);
						return -1; // contradictory mark
					}
					main[Nodes[e][1]] = main[Nodes[e][0]];
				}
				else
				{
					main[Nodes[e][0]] = main[Nodes[e][1]];
				}
			}
		}
	}
	// END: Calculate main index

	unsigned __int8 mainIndex = 0;
	for (int i = 0; i < 8; ++i)
	{
		if (main[i] == 1)
			mainIndex |= (0x01 << i);
	}
	const int * contTableLine = contTable[mainIndex];
	int Ci = 0;
	for (int vInd = 0; contTableLine[vInd] != -1 && vInd < 32; vInd += 2, ++Ci)
	{
		int LastFace = contTableLine[vInd];
		DXFinalCycle &FinalCycle = pBigCell->GetGData()->FinalCycles[Ci];
		for (; contTableLine[vInd] != -2; vInd += 2)
		{
			FinalCycle.PutBack(bEdges[contTableLine[vInd + 1]], false);
			int nextFace = contTableLine[vInd + 2];
			if (nextFace == -2)
				nextFace = LastFace;
			if (GetBound(nextFace) != NULL)// if CurFace contains an additional point
				FinalCycle.PutBack(nextFace, true);
		}
	}

	return Ci; // The number of non empty final cycles
}

//int DXCell5X::HealCell(const DXCellInd &Key, const FEP FaceEdgeP)
//{
////	return 0;
//	// Reconstruct triTable
//	int triTable[256][32] =
//	{ { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1 },
//	{ 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1 },
//	{ 3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1 },
//	{ 3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1 },
//	{ 9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1 },
//	{ 9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1 },
//	{ 2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1 },
//	{ 8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1 },
//	{ 9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1 },
//	{ 4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1 },
//	{ 3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1 },
//	{ 1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1 },
//	{ 4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1 },
//	{ 4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1 },
//	{ 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1 },
//	{ 1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1 },
//	{ 5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1 },
//	{ 2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1 },
//	{ 9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1 },
//	{ 0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1 },
//	{ 2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1 },
//	{ 10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1 },
//	{ 4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1 },
//	{ 5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1 },
//	{ 5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1 },
//	{ 9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1 },
//	{ 0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1 },
//	{ 1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1 },
//	{ 10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1 },
//	{ 8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1 },
//	{ 2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1 },
//	{ 7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1 },
//	{ 9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1 },
//	{ 2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1 },
//	{ 11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1 },
//	{ 9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1 },
//	{ 5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1 },
//	{ 11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1 },
//	{ 11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1 },
//	{ 1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1 },
//	{ 9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1 },
//	{ 5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1 },
//	{ 2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1 },
//	{ 0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1 },
//	{ 5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1 },
//	{ 6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1 },
//	{ 0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1 },
//	{ 3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1 },
//	{ 6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1 },
//	{ 5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1 },
//	{ 1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1 },
//	{ 10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1 },
//	{ 6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1 },
//	{ 1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1 },
//	{ 8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1 },
//	{ 7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1 },
//	{ 3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1 },
//	{ 5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1 },
//	{ 0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1 },
//	{ 9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1 },
//	{ 8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1 },
//	{ 5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1 },
//	{ 0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1 },
//	{ 6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1 },
//	{ 10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1 },
//	{ 10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1 },
//	{ 8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1 },
//	{ 1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1 },
//	{ 3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1 },
//	{ 0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1 },
//	{ 10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1 },
//	{ 0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1 },
//	{ 3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1 },
//	{ 6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1 },
//	{ 9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1 },
//	{ 8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1 },
//	{ 3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1 },
//	{ 6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1 },
//	{ 0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1 },
//	{ 10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1 },
//	{ 10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1 },
//	{ 1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1 },
//	{ 2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1 },
//	{ 7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1 },
//	{ 7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1 },
//	{ 2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1 },
//	{ 1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1 },
//	{ 11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1 },
//	{ 8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1 },
//	{ 0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1 },
//	{ 7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1 },
//	{ 10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1 },
//	{ 2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1 },
//	{ 6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1 },
//	{ 7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1 },
//	{ 2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1 },
//	{ 1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1 },
//	{ 10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1 },
//	{ 10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1 },
//	{ 0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1 },
//	{ 7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1 },
//	{ 6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1 },
//	{ 8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1 },
//	{ 6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1 },
//	{ 4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1 },
//	{ 10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1 },
//	{ 8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1 },
//	{ 0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1 },
//	{ 1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1 },
//	{ 8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1 },
//	{ 10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1 },
//	{ 4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1 },
//	{ 10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1 },
//	{ 5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1 },
//	{ 11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1 },
//	{ 9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1 },
//	{ 6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1 },
//	{ 7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1 },
//	{ 3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1 },
//	{ 7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1 },
//	{ 9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1 },
//	{ 3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1 },
//	{ 6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1 },
//	{ 9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1 },
//	{ 1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1 },
//	{ 4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1 },
//	{ 7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1 },
//	{ 6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1 },
//	{ 3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1 },
//	{ 0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1 },
//	{ 6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1 },
//	{ 0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1 },
//	{ 11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1 },
//	{ 6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1 },
//	{ 5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1 },
//	{ 9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1 },
//	{ 1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1 },
//	{ 1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1 },
//	{ 10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1 },
//	{ 0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1 },
//	{ 5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1 },
//	{ 10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1 },
//	{ 11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1 },
//	{ 9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1 },
//	{ 7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1 },
//	{ 2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1 },
//	{ 8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1 },
//	{ 9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1 },
//	{ 9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1 },
//	{ 1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1 },
//	{ 9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1 },
//	{ 9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1 },
//	{ 5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1 },
//	{ 0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1 },
//	{ 10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1 },
//	{ 2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1 },
//	{ 0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1 },
//	{ 0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1 },
//	{ 9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1 },
//	{ 5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1 },
//	{ 3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1 },
//	{ 5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1 },
//	{ 8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1 },
//	{ 9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1 },
//	{ 0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1 },
//	{ 1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1 },
//	{ 3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1 },
//	{ 4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1 },
//	{ 9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1 },
//	{ 11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1 },
//	{ 11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1 },
//	{ 2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1 },
//	{ 9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1 },
//	{ 3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1 },
//	{ 1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1 },
//	{ 4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1 },
//	{ 4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1 },
//	{ 0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1 },
//	{ 3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1 },
//	{ 3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1 },
//	{ 0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1 },
//	{ 9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1 },
//	{ 1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ 0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
//	{ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 } };
//	int newTriTable[256][32];
//	const int bEdges[12] = { 2, 1, 0, 3, 6, 5, 4, 7, 10, 11, 9, 8 };// MC edge index to my edge index
//	for (int Case = 0; Case < 256; ++Case)
//	{
//		int *Nums = triTable[Case];
//		if (Nums[0] == -1)
//			continue;
//
//		int FConts[4][16];
//		int Find = 0;
//		for (; Find < 4; ++Find)
//		{
//			for (int i = 0; i < 16; ++i)
//				FConts[Find][i] = -1;
//			int bb = 0;
//			for (; bb < 16; bb+=3)
//			{
//				if (Nums[bb] == -1)
//					break;
//				if (Nums[bb] == -2)
//					continue;
//				for (int e = 0; e < 3; ++e)
//				{
//					FConts[Find][e] = Nums[bb + e];
//					Nums[bb + e] = -2;
//				}
//				break;
//			}
//			if (FConts[Find][0] == -1)
//				break;
//			FConts[Find][3] = -2;
//			int ContSizes[4];
//			ContSizes[0] = 3;
//			int ContStart[4];
//			ContStart[0] = 0;
//			int newConts = 1;
//			for (int iConts = 0; iConts < newConts; ++iConts)
//			{
//				bool Stop = false;
//				for (int t = 3; Nums[t] != -1 && !Stop; t += 3)// for all triangles
//				{
//					if (Nums[t] == -2)
//						continue;
//					// ќбъединить контур с треугольником
//					// Ќайти совпадающие ребра
//					for (int te = 0; te < 3 && !Stop; ++te)
//					{
//						int beg = Nums[t + te];
//						int end = Nums[t + (te + 1) % 3];
//						for (int ce = ContStart[iConts]; ce < ContStart[iConts] + ContSizes[iConts]; ++ce)
//						{
//							if (FConts[Find][ce] == end)
//							{
//								if (FConts[Find][ContStart[iConts] + (ce + 1 - ContStart[iConts]) % ContSizes[iConts]] == beg)
//								{
//									// –ебра совпадают -> объединить
//									int bufNums[16];
//									for (int ind = 0; ind < ContSizes[iConts] - 1; ++ind)
//									{// старый контур
//										bufNums[ind] = FConts[Find][ContStart[iConts] + (ind + ce + 1 - ContStart[iConts]) % ContSizes[iConts]];
//									}
//									for (int ind = 0; ind < 2; ++ind)
//									{// новый кусок
//										bufNums[ContSizes[iConts] - 1 + ind] = Nums[t + (te + 1 + ind) % 3];
//										Nums[t + (te + 1 + ind) % 3] = -2;
//									}
//									Nums[t + te] = -2;
//									for (int ind = 0; ind < ContSizes[iConts] + 1; ++ind)
//									{
//										FConts[Find][ContStart[iConts] + ind] = bufNums[ind];
//									}
//									++ContSizes[iConts];
//									FConts[Find][ContStart[iConts] + ContSizes[iConts]] = -2;
//									--iConts;
//									Stop = true;
//									break;
//								}
//							}
//						}
//					}
//				}
//			}
//		}
//		int *newNums = newTriTable[Case];
//		for (int i = 0; i < 32; ++i)
//			newNums[i] = -1;
//		int o = 0;
//		for (int k = 0; k < Find; ++k)
//		{
//			int Last = -1;
//			int bo = o;
//			for (int i = 0; FConts[k][i] >= 0; ++i)
//			{
//				newNums[o++] = FConts[k][i];
//				++o;
//				Last = FConts[k][i];
//			}
//			newNums[o++] = -2;
//			newNums[o++] = -2;
//			for (int i = 0; FConts[k][i / 2] >= 0; i += 2)
//			{
//				int FaceNum = EdgeFace[bEdges[newNums[bo + i]]][0];
//				if (FaceNum == EdgeFace[bEdges[Last]][0] || FaceNum == EdgeFace[bEdges[Last]][1])
//				{
//					newNums[bo + 1 + i] = FaceNum;
//				}
//				else
//				{
//					newNums[bo + 1 + i] = EdgeFace[bEdges[newNums[bo + i]]][1];
//				}
//				Last = newNums[bo + i];
//			}
//		}
//		//CString S;
//		//OutputDebugString("\n{");
//
//		//S.Format(" %d", newNums[1]);
//		//OutputDebugString(S);
//		//S.Format(", %d", newNums[0]);
//		//OutputDebugString(S);
//		//for (int i = 2; i < 32; i+=2)
//		//{
//		//	S.Format(", %d", newNums[i + 1]);
//		//	OutputDebugString(S);
//		//	S.Format(", %d", newNums[i]);
//		//	OutputDebugString(S);
//		//}
//
//		//OutputDebugString("},");
//	}
//	double kX = Key.Ix * pBigCell->GetGData()->StepX;
//	double kY = Key.Iy * pBigCell->GetGData()->StepY;
//	double kZ = Key.Iz * pBigCell->GetGData()->StepZ;
//	double dX = pBigCell->GetGData()->StepX;
//	double dY = pBigCell->GetGData()->StepY;
//	double dZ = pBigCell->GetGData()->StepZ;
//	BBox Box;
//	Box.Expand(BPoint(kX, kY, kZ, 1.));
//	Box.Expand(BPoint(kX + dX, kY + dY, kZ + dZ, 1.));
//	double Val[12];
//	for (int i = 0; i < 12; ++i)
//	{
//		const DXEdge *pEdge = GetEdge(i);
//		if (!pEdge)
//			continue;
//		Val[i] = pEdge->GetZ(pBigCell->GetGData()->pActMemory);
//	}
//	for (int i = 0; i < 12; ++i)
//		if (Val[i] < 0)
//			return GetEdge(i)->GetDegraded();
//	// Check edges for consistency
//	int vertFlags[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
//	for (int i = 0; i < 12; ++i)
//	{
//		const DXEdge *pEdge = GetEdge(i);
//		if (!pEdge)
//			continue;
//		int side = pEdge->GetRout() ? -1 : 1;
//		vertFlags[EdgeVert[i][0]] = side;
//		vertFlags[EdgeVert[i][1]] = -side;
//
//	}
//	return 0;
//}

int DXCell5X::CalcWholePointsNum(const FEP FaceEdgeP)
{
	int Res = 0;
	for (int i = 0; i < 6; ++i)
		Res += FaceEdgeP[i][PC];
	return Res;
}